## 5. 关联容器

关联容器的侧重点在于查找，其中有序关联容器的初衷在于键值有序+快速的查找（使用红黑树可使查找插入、删除、查找操作的时间复杂度达到$O(logN)$），而无序关联容器的初衷只在于更快的查找（使用哈希表可使插入、删除、查找操作的时间复杂度达到$O(1)$）。

其中文件[AVLTree.h](AVLTree.h)按照规则简单的实现了AVL树，但仅仅支持插入等少数几个操作，尤其是不支持删除单个指定元素的操作。

对于set、map、multiset和multimap这些有序关联容器其内部是使用红黑树来实现的，而对于像hash_set、hash_map、hash_multiset以及hash_multimap（对于对应当前C++ STL下的unordered_set、unordered_map、unordered_multiset和unordered_multimap）这些无序关联容器则是通过哈希表来实现的。



### 5.1 平衡二叉树

为了能够深入的理解有序关联容器内部所使用的红黑树，我们必须先从平衡二叉树然后过渡到红黑树，分析最底层的原理才能更好的理解各种有序关联容器的实现。

#### 5.1.1 AVL树



#### 5.1.2 红黑树

红黑树的本质就是通过二叉树的方式来模拟构建2-3-4树。在《算法4》中我们其实已经了解以各种比较特殊的红黑树——左倾红黑树，它为了实现的方便，模拟构建的是2-3树而不是2-3-4树，但从本质上讲两者都是相同的。

假设一个二叉树符合红黑树的规定，那么以如下几种情况插入会破坏红黑树的平衡性（如下图所示）：

1. 向一个左倾3-结点“左左”、“左右”插入
2. 向一个右倾3-结点“右左”、“右右”插入
3. 向一个4-结点以任何方式插入

<img src="../../image/红黑树插入.jpg" alt="红黑树插入" style="zoom: 50%;" />



从上面的描述我们知道，向一个4-结点插入新的红结点会造成复杂的插入处理动作，因此SGI STL采用如下的方式来避免红黑树出现向一个4-结点插入的情况：在插入操作向下递归游走的时候及时将路径上的4-结点分解成3-结点或者2-结点，并将提取出的红结点插入到上一层，从而尽可能在新红节点插入的位置发生向4-结点插入的情况！

<img src="../../image/屏幕截图 2021-01-22 231315.png" alt="屏幕截图 2021-01-22 231315" style="zoom:65%;" />

为了强调SGI STL关于对红黑树的实现，我并不将RB-tree的代码解读放在红黑树原理小节中，而是单独放在下一节中。



