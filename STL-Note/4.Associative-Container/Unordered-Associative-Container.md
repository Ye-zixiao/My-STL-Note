### 5.4 å“ˆå¸Œè¡¨åŸºç¡€

å“ˆå¸Œè¡¨èƒ½å¤Ÿå®ç°å¿«é€Ÿæ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œçš„è¯€çªåœ¨äºï¼šæ’å…¥æ—¶ä¼šæ ¹æ®å“ˆå¸Œå‡½æ•°ç›´æ¥è®¡ç®—æ“ä½œå…ƒç´ çš„å“ˆå¸Œå€¼ï¼Œç„¶åå°†è¯¥å“ˆå¸Œå€¼ä½œä¸ºæ•°ç»„ä¸­çš„ä¸‹æ ‡å¹¶å°†å…¶å­˜æ”¾åœ¨å¯¹åº”çš„æ§½ä¸­ã€‚è¿™æ ·ï¼Œä¸‹æ¬¡è¿›è¡ŒæŸ¥æ‰¾ã€åˆ é™¤æ—¶ä»…ä»…éœ€è¦å†æ¬¡è®¡ç®—å“ˆå¸Œå€¼å°±å¯ä»¥å¾—åˆ°å¿«é€Ÿçš„å“åº”ï¼Œä¸è¿‡ç¼ºç‚¹å°±æ˜¯å­˜å‚¨åçš„å…ƒç´ ä¹‹é—´å¹¶ä¸ä¼šåƒçº¢é»‘æ ‘é‚£æ ·å‘ˆç°æœ‰åºçš„çŠ¶æ€ï¼Œæ•…å“ˆå¸Œè¡¨æ˜¯ä¸€ä¸ªå…¸å‹çš„æ— åºå®¹å™¨ã€‚

å“ˆå¸Œè¡¨è¿˜æœ‰ä¸€ä¸ªé‡å¤§é—®é¢˜åœ¨äºå¤šä¸ªæ‰€æ“ä½œå…ƒç´ è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼å¯èƒ½ç›¸åŒï¼Œæ˜¾ç„¶æˆ‘ä»¬ä¸èƒ½å°†å®ƒä»¬éƒ½å­˜æ”¾åœ¨æ•°ç»„ç›¸åŒçš„æ§½ä¸­ï¼Œè¿™ä¾¿æ˜¯å…ƒç´ çš„ç¢°æ’é—®é¢˜ã€‚è§£å†³è¿™ç§é—®é¢˜ä¸»è¦æœ‰æ¢æµ‹æ³•å’Œæ‹‰é“¾æ³•ä¸¤ç§è§£å†³é€”å¾„ã€‚



#### 5.4.1.1 æ¢æµ‹æ³•

å¸¸è§çš„æ¢æµ‹æ³•å°±æ˜¯ï¼šå½“æ“ä½œå…ƒç´ å“ˆå¸Œå€¼æ‰€å¯¹åº”çš„ä¸‹æ ‡å·²ç»æœ‰ä¸åŒçš„å…ƒç´ å­˜åœ¨æ—¶ï¼Œè‡ªåŠ¨å°†ä¸‹æ ‡ï¼ˆæ‰€å¾—å“ˆå¸Œå€¼ï¼‰çº¿æ€§é€’å¢ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„ä½ç½®ã€‚è¿™ç§æ–¹æ³•çš„ç¼ºç‚¹å°±æ˜¯å®ƒå¾ˆå®¹æ˜“é€ æˆä¸»é›†å›¢çš„é—®é¢˜ï¼Œå³å…·æœ‰ç›¸åŒå“ˆå¸Œå€¼çš„å…ƒç´ å› ä¸ºçº¿æ€§æ¢æµ‹å¯¼è‡´æˆç‰‡è¿ç»­å­˜æ”¾ï¼Œå¹¶è¿›ä¸€æ­¥å¯¼è‡´ç›¸è¿‘å“ˆå¸Œå€¼çš„å…ƒç´ ä¹Ÿä¸å¾—ä¸è·Ÿåœ¨åé¢è¿ç»­å­˜æ”¾ã€‚

è€ŒäºŒæ¬¡æ¢æµ‹æ³•åˆ™æ˜¯ç”¨æ¥è§£å†³ä¸Šè¿°ä¸»é›†å›¢é—®é¢˜è€Œå‡ºç°çš„ï¼Œå®ƒçš„åŸç†ååˆ†ç®€å•ï¼Œå³åœ¨å‘ç”Ÿç¢°æ’çš„æ—¶å€™ä»¥å‡½æ•°$F(i)=i^2$çš„ç»“æœæŒ¨ä¸ªå°è¯•æ‰€å¾—å“ˆå¸Œå€¼H+1ã€H+4ã€H+9...è¿™æ ·çš„æ–°ä¸‹æ ‡æ¥çœ‹çœ‹å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„ä½ç½®æ˜¯å¦å¯ä»¥å­˜æ”¾æ–°çš„å…ƒç´ ã€‚ä¸è¿‡è¿™ç§æ–¹æ³•ä¹Ÿæœ‰å¾ˆå¤šç¼ºç‚¹ï¼Œæ¯”å¦‚è®¡ç®—å¤æ‚ã€åˆå®¹æ˜“äº§ç”Ÿæ¬¡é›†å›¢ç­‰ä¸€ç³»åˆ—é—®é¢˜ã€‚



#### 5.4.1.2 æ‹‰é“¾æ³•

åœ¨å®é™…ä¸­ï¼ŒHashè¡¨çš„å®ç°æ›´æ„¿æ„é‡‡çº³æ‹‰é“¾æ³•ï¼Œå³åœ¨Hashè¡¨ä¸­çš„æ¯ä¸€ä¸ªè¡¨æ ¼ä¸­ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ä¸€ä¸ªå…·æœ‰ç›¸åŒå“ˆå¸Œå€¼çš„å…ƒç´ éƒ½ä¼šæŒ‚æ¥åˆ°ç›¸åŒçš„é“¾è¡¨ä¸­ï¼Œè¿™æ ·ä¹Ÿå°±è§£å†³äº†ç¢°æ’é—®é¢˜ã€‚è‡³äºæ€§èƒ½ï¼Œåªè¦é“¾è¡¨è¶³å¤ŸçŸ­æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„æ€§èƒ½ä¹Ÿå¹¶ä¸ä¼šæ”¶åˆ°å¤ªå¤§çš„å½±å“ã€‚

Javaä¸­é‡‡ç”¨äº†ä¸€ç§æ›´è¿›ä¸€æ­¥çš„æ‹‰é“¾æ³•ï¼Œå³åœ¨Hashè¡¨çš„è¡¨æ ¼ä¸­åœ¨å°¾éšå…ƒç´ è¾ƒå°‘çš„æƒ…å†µä¸‹ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ï¼Œå½“é“¾è¡¨ä¸­çš„æ•°é‡è¶…è¿‡äº†ä¸€ä¸ªé˜ˆå€¼åå°±è½¬æ¢ä¸ºæ ‘çš„å½¢å¼ã€‚è¿™æ ·ä¹Ÿæ˜¯ä¸€ç§å¾ˆå¥½çš„æ€è·¯ï¼Œä¸è¿‡æ›´ä¸€èˆ¬å¤„ç†Hashè¡¨ä¸­å…ƒç´ è¿‡å¤šå®¹æ˜“å¼•å‘é•¿é“¾è¡¨çš„é€”å¾„æ˜¯æ‰©å¤§Hashè¡¨+é‡æ–°æ’å…¥åŸHashè¡¨ä¸­å…ƒç´ ã€‚å½“ç„¶è¿™å¹¶ä¸æ˜¯è¯´Javaä¸­çš„Hashè¡¨ä¸æ‰©å»ºï¼Œå› ä¸ºæˆ‘ä¹Ÿæ²¡çœ‹è¿‡Javaå…·ä½“æ€ä¹ˆåšğŸ˜‚ã€‚

SGI STL Hashè¡¨çš„å®ç°ä¾¿æ˜¯é‡‡ç”¨äº†ç¬¬ä¸€ç§æ–¹æ³•ï¼Œå¹¶ä¸”æŒ‰ç…§å¦‚ä¸‹è§„èŒƒå‘½åHashè¡¨ä¸­çš„ç»„ä»¶ï¼š1ï¼‰å°†Hashè¡¨è¡¨æ ¼ç»´æŠ¤çš„é“¾è¡¨ç§°ä¸ºæ¡¶bucketï¼Œæ¯ä¸€ä¸ªæ¡¶ä¸­å­˜å‚¨ç€å…·æœ‰ç›¸åŒHashå€¼çš„å…ƒç´ ï¼›2ï¼‰å°†æ¡¶ä¸­çš„æ¯ä¸€ä¸ªè®°å½•å…ƒç´ çš„èŠ‚ç‚¹ç§°ä¸ºæ¡¶èŠ‚ç‚¹ï¼Œè¿™æ˜¯æˆ‘ä»¬å®ç°Hashè¡¨çš„æœ€å°å•å…ƒï¼ŒHashè¡¨è¡¨æ ¼å®é™…è®°å½•çš„å°±æ˜¯ä¸€ä¸ªæŒ‡å‘æ¡¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚å…·ä½“è§ä¸‹å›¾æ‰€ç¤ºï¼š

<img src="../../image/Snipaste_2021-03-09_09-23-01.png" alt="Snipaste_2021-03-09_09-23-01" style="zoom:80%;" />



#### 5.4.1.3 hashå‡½æ•°

<img src="../../image/Snipaste_2021-04-07_11-48-15.png" alt="Snipaste_2021-04-07_11-48-15" style="zoom: 80%;" />

é¡ºä¾¿æä¸‹ï¼Œè‹¥ä¸€ä¸ªç”¨æˆ·éœ€è¦ä¸ºä¸€ä¸ªè‡ªå®šä¹‰çš„ç±»æä¾›ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œåˆ™ç”¨æˆ·è‡ªå·±å¿…é¡»ä¸ºæ ‡å‡†åº“ä¸­çš„å“ˆå¸Œå‡½æ•°åšä¸€ä¸ªå…¨ç‰¹åŒ–å¤„ç†ï¼Œå¹¶åŠ å…¥åˆ°stdçš„å‘½åç©ºé—´ä¸­ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```c++
class Test {
 public:
  Test(std::string str) : string_(std::move(str)) {}
  [[nodiscard]] const std::string &get() const { return string_; }
  void set(const std::string &str) { string_ = str; }
  
  // ä»æ ‡å‡†åº“ä¸­å…³äºæ— åºå…³è”å®¹å™¨çš„ç±»å£°æ˜å¯ä»¥çœ‹å‡ºè‡ªå®šä¹‰ç±»ç±»å‹å¿…é¡»é‡è½½operator==
  // è¿ç®—ç¬¦æˆ–è€…ä¼ é€’è¿›å»ä¸€ä¸ªæ¯”è¾ƒå‡½æ•°ï¼
  friend inline bool operator==(const Test &lhs, const Test &rhs) {
	return lhs.string_ == rhs.string_;
  }
 private:
  std::string string_;
};

namespace std {
template<>
struct hash<Test> {
  using result_type = size_t;
  using argument_type = Test;
  result_type operator()(const argument_type &arg) const {
	return hash<string>()(arg.get());
  }
};
} // namespace std
```



### 5.5 hashtable

Hashè¡¨æ˜¯C++ STLä¸­å®ç°æ— åºå…³è”å®¹å™¨çš„åº•å±‚åŸºç¡€ï¼Œå…¶æºæ–‡ä»¶ä½äº[stl_hashtable.h](stl_hashtable.h)ä¸­ï¼Œæ•´ä½“ç›¸å¯¹äºå‰é¢å‡ ä¸ªå®¹å™¨è€Œè¨€å¹¶ä¸æ˜¯å¾ˆéš¾ã€‚å¯¹äºå®ƒçš„å®ç°ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨äºè¿™å‡ ä¸ªéƒ¨åˆ†ï¼š

1. **hashtableæ¡¶èŠ‚ç‚¹ã€è¿­ä»£å™¨ã€æ•°æ®ç»“æ„çš„å®ç°**
2. hashtableçš„æ„é€ å’Œææ„è¿‡ç¨‹
3. **hashtableçš„å…ƒç´ æ’å…¥ä¸åˆ é™¤æ“ä½œ**
4. å…¶ä»–æ“ä½œï¼Œçœ‹çœ‹å°±è¡Œ



#### 5.5.1 hashtableæ¡¶èŠ‚ç‚¹å’Œè¿­ä»£å™¨

##### 5.5.1.1 hashtableæ¡¶èŠ‚ç‚¹

```c++
//hashæ¡¶ä¸­çš„ç»“ç‚¹
template <class _Val>
struct _Hashtable_node
{
  _Hashtable_node* _M_next;
  _Val _M_val;
};  
```



##### 5.5.1.2 hashtableè¿­ä»£å™¨

æ ¹æ®æºä»£ç å¯ä»¥çœ‹å‡ºï¼Œhashtableè¿­ä»£å™¨æ˜¯ä¸€ç§å‰å‘è¿­ä»£å™¨ï¼Œè¿™ä¾¿æ„å‘³ç€å¯¹äºhashtableçš„è¿­ä»£å™¨è€Œè¨€ï¼Œå®ƒæœ€ä¸ºä¸»è¦çš„å·¥ä½œå°±æ˜¯é‡è½½`operator++()`ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç›®çš„ï¼Œè¿­ä»£å™¨åœ¨å†…éƒ¨è®°å½•äº†â‘ ä¸€ä¸ªæŒ‡å‘å…·ä½“hashtableæ¡¶èŠ‚ç‚¹çš„æŒ‡é’ˆå’Œâ‘¡ä¸€ä¸ªæŒ‡å‘hashtableçš„æŒ‡é’ˆã€‚å‰è€…çš„ç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿è¿­ä»£å™¨åœ¨æ¡¶ä¸­èŠ‚ç‚¹é—´è¿›è¡Œæ­¥è¿›ï¼Œè€Œåè€…çš„ç›®çš„æ˜¯ä¸ºäº†èƒ½å¤Ÿä½¿å¾—è¿­ä»£å™¨èƒ½å¤Ÿå–å¾—ä¸‹ä¸€ä¸ªç´§æŒ¨ä¸”æœ‰æ•ˆè¡¨æ ¼(æ¡¶)çš„ä¸‹æ ‡ï¼Œç„¶åå–å‡ºè¡¨æ ¼ä¸­æŒ‡é’ˆæ›´æ–°æŒ‡å‘æ¡¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

ä¸ºäº†èƒ½å¤Ÿæ–¹ä¾¿hashtableè¿­ä»£å™¨å¯¹å“ˆå¸Œè¡¨çš„è®¿é—®ï¼Œå“ˆå¸Œè¡¨è¿™ä¸ªç±»ä¼šå°†å“ˆå¸Œè¡¨è¿­ä»£å™¨ç±»è®¾ç½®ä¸ºè‡ªå·±çš„å‹å…ƒç±»ï¼

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
struct _Hashtable_iterator {
  /* ... */
  typedef forward_iterator_tag iterator_category;
  /* ... */

  _Node* _M_cur;// æŒ‡å‘å½“å‰çš„hashæ¡¶ä¸­çš„ç»“ç‚¹
  _Hashtable* _M_ht;// æŒ‡å‘hashè¡¨

  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) 
    : _M_cur(__n), _M_ht(__tab) {}
  _Hashtable_iterator() {}
  reference operator*() const { return _M_cur->_M_val; }
  iterator& operator++();
  iterator operator++(int);
  bool operator==(const iterator& __it) const
    { return _M_cur == __it._M_cur; }
  bool operator!=(const iterator& __it) const
    { return _M_cur != __it._M_cur; }
};

template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
          class _All>
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()
{
  const _Node* __old = _M_cur;
  _M_cur = _M_cur->_M_next;
  if (!_M_cur) {
    // å–å‡ºåŸæ¥hashtableæ¡¶æ‰€åœ¨çš„ä¸‹æ ‡
    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);
    // ä¾æ¬¡åœ¨hashtableç´§æŒ¨ç€çš„è¡¨æ ¼ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„è¡¨æ ¼ï¼ˆæ¡¶ï¼‰ï¼Œå–å‡ºå…¶ä¸­çš„æ¡¶èŠ‚ç‚¹æŒ‡é’ˆç»™_M_cur
    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())
      _M_cur = _M_ht->_M_buckets[__bucket];
  }
  return *this;
}
```



#### 5.5.2 hashtableçš„æ•°æ®ç»“æ„

hashtableçš„æ•°æ®ç»“æ„éå¸¸ç®€å•ï¼Œåœ¨å†…éƒ¨æœ€ä¸ºä¸»è¦çš„ç»„ä»¶å°±æ˜¯ç”±vectoré€ å°±çš„è®°å½•hashtableæ¡¶èŠ‚ç‚¹æŒ‡é’ˆçš„æ•°ç»„ï¼Œå…·ä½“åä¸º\_M\_bucketsã€‚è€Œå…¶ä»–çš„ç»„ä»¶å°±å¾ˆæ™®é€šï¼Œä¸»è¦åŒ…æ‹¬ä¸€ä¸ªè®¡ç®—å“ˆå¸Œå€¼çš„å“ˆå¸Œå‡½æ•°å¯¹è±¡\_M_hashã€ä¸€ä¸ªåˆ¤æ–­hashtableæ¡¶èŠ‚ç‚¹ä¸Šå…ƒç´ é”®å€¼keyæ˜¯å¦ç›¸ç­‰çš„æ¯”è¾ƒå™¨\_M_equalsã€ä¸€ä¸ªä»å€¼åŸŸä¸­æå–é”®å€¼keyçš„æå–å™¨\_M\_get\_keyå’Œä¸€ä¸ªè®°å½•hashtableä¸­æ¡¶èŠ‚ç‚¹æ•°çš„è®¡æ•°å™¨\_M\_num_elementsã€‚

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
public:
    /* ... */
private:
  typedef _Hashtable_node<_Val> _Node;
    
  // å“ˆå¸Œè¡¨è¿­ä»£å™¨æ˜¯å“ˆå¸Œè¡¨çš„å‹å…ƒç±»
  friend struct
  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;

public:
  typedef _Alloc allocator_type;
  allocator_type get_allocator() const { return allocator_type(); }
private:
  typedef simple_alloc<_Node, _Alloc> _M_node_allocator_type;
  _Node* _M_get_node() { return _M_node_allocator_type::allocate(1); }
  void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); }

private:
  hasher                _M_hash;
  key_equal             _M_equals;
  _ExtractKey           _M_get_key;
  vector<_Node*,_Alloc> _M_buckets;
  size_type             _M_num_elements;

  /* ... */
};
```



#### 5.5.3 hashtableæ„é€ /ææ„è¿‡ç¨‹

##### 5.5.3.1 é»˜è®¤æ„é€ å‡½æ•°

hashtableçš„é»˜è®¤æ„é€ è¿‡ç¨‹å…¶å®éå¸¸ç®€å•ï¼Œå®ƒé¦–å…ˆä¼šæ ¹æ®æŒ‡å®šçš„å®å‚åˆå§‹åŒ–å„ä¸ªæ•°æ®æˆå‘˜ï¼Œç„¶åæ ¹æ®ç”¨æˆ·æŒ‡å®šçš„æ¡¶èŠ‚ç‚¹æ•°nè°ƒç”¨`__stl_next_prime()`å‡½æ•°è®¡ç®—å‡ºæœ€ä¸ºæ¥è¿‘ï¼ˆä½†å¤§äºnï¼‰çš„è´¨æ•°ï¼Œå¹¶ä»¥æ­¤ä¸ºhashtableçš„bucket vectoré¢„åˆ†é…ç©ºé—´ï¼Œå®Œæˆä¹‹åˆæ¯ä¸€ä¸ªè¡¨æ ¼ä¸­è®°å½•çš„éƒ½æ˜¯ç©ºæŒ‡é’ˆã€‚

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
  /* ... */
public:
  hashtable(size_type __n,
            const _HashFcn&    __hf,
            const _EqualKey&   __eql,
            const _ExtractKey& __ext,
            const allocator_type& __a = allocator_type())
    : __HASH_ALLOC_INIT(__a)
      _M_hash(__hf),
      _M_equals(__eql),
      _M_get_key(__ext),
      _M_buckets(__a),
      _M_num_elements(0)
  {
    _M_initialize_buckets(__n);
  }

  hashtable(const hashtable& __ht)
    : __HASH_ALLOC_INIT(__ht.get_allocator())
      _M_hash(__ht._M_hash),
      _M_equals(__ht._M_equals),
      _M_get_key(__ht._M_get_key),
      _M_buckets(__ht.get_allocator()),
      _M_num_elements(0)
  {
    _M_copy_from(__ht);
  }
    
  ~hashtable() { clear(); }
    
private:
  size_type _M_next_size(size_type __n) const
    { return __stl_next_prime(__n); }

  void _M_initialize_buckets(size_type __n)
  {
    const size_type __n_buckets = _M_next_size(__n);
    _M_buckets.reserve(__n_buckets);
    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);
    _M_num_elements = 0;
  }
  /* ... */
};
```

`__stl_next_prime()`å‡½æ•°çš„å®ç°å¦‚ä¸‹ï¼š

```c++
enum { __stl_num_primes = 28 };

static const unsigned long __stl_prime_list[__stl_num_primes] =
{
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, 
  1610612741ul, 3221225473ul, 4294967291ul
};

inline unsigned long __stl_next_prime(unsigned long __n)
{
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
  const unsigned long* pos = lower_bound(__first, __last, __n);
  return pos == __last ? *(__last - 1) : *pos;
}
```



##### 5.5.3.2 æ‹·è´æ„é€ å‡½æ•°

æ‹·è´æ„é€ å‡½æ•°çš„å®ç°ä¹Ÿå¹¶ä¸æ˜¯å¾ˆéš¾ï¼Œå®ƒçš„å¤§éƒ¨åˆ†å·¥ä½œéƒ½æ˜¯ç”±ä¸€ä¸ªåä¸º`_M_copy_from()`çš„å‡½æ•°å®Œæˆçš„ã€‚è¯¥å‡½æ•°åœ¨æ‰§è¡Œä¹‹åˆï¼Œä¼šæ¸…ç†bucket vectorå¹¶é¢„åˆ†é…å¥½å³ä¾§å¾…æ‹·è´hashtableçš„bucket vectorç›¸åŒå¤§å°çš„ç©ºé—´ã€‚ç„¶åæŒ¨ä¸ªéå†å³ä¾§å“ˆå¸Œè¡¨bucket vectorä¸­çš„è¡¨æ ¼ï¼Œè‹¥æ˜¯è¡¨æ ¼ä¸­å­˜åœ¨æœ‰æ•ˆçš„æ¡¶ï¼Œåˆ™ä»ä¸­å®Œæ•´åœ°æ‹·è´æ¡¶ä¸­çš„é“¾è¡¨åˆ°å½“å‰çš„hashtableå¯¹åº”è¡¨æ ¼ä¹‹ä¸­ï¼›å¦åˆ™ç›´æ¥è·³åˆ°ä¸‹ä¸€ä¸ªä½ç½®ï¼Œç›´åˆ°èµ°åˆ°bucket vectorçš„å°½å¤´ã€‚

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
  /* ... */
public:
  hashtable(const hashtable& __ht)
    : __HASH_ALLOC_INIT(__ht.get_allocator())
      _M_hash(__ht._M_hash),
      _M_equals(__ht._M_equals),
      _M_get_key(__ht._M_get_key),
      _M_buckets(__ht.get_allocator()),
      _M_num_elements(0)
  {
    _M_copy_from(__ht);
  }
    /* ... */
};

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::_M_copy_from(const hashtable& __ht)
{
  _M_buckets.clear();
  _M_buckets.reserve(__ht._M_buckets.size());
  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);
  __STL_TRY {
    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
      const _Node* __cur = __ht._M_buckets[__i];
      if (__cur) {
        // æ‹·è´htä¸­çš„ä¸€ä¸ªæœ‰æ•ˆæ¡¶
        _Node* __copy = _M_new_node(__cur->_M_val);
        _M_buckets[__i] = __copy;

        // è¿­ä»£æ‹·è´æ¡¶ä¸­çš„ä¸²é“¾
        for (_Node* __next = __cur->_M_next; 
             __next; 
             __cur = __next, __next = __cur->_M_next) {
          __copy->_M_next = _M_new_node(__next->_M_val);
          __copy = __copy->_M_next;
        }
      }
    }
    _M_num_elements = __ht._M_num_elements;
  }
  __STL_UNWIND(clear());
}
```



#### 5.5.4 ==hashtableå…ƒç´ æ’å…¥æ“ä½œ==

##### 5.5.4.1 hashtableæ‰©å»ºé‡æ•´

æˆ‘ä»¬å¯ä»¥é¢„è§éšç€æ–°çš„å…ƒç´ ä¸æ–­åœ°æ’å…¥ï¼Œhashtableä¸­çš„å…ƒç´ æ•°é‡ä¼šä¸æ–­åœ°å¢åŠ å¹¶è¶…è¿‡bucket vectoræœ¬èº«çš„å¤§å°ã€‚æŒ‰ç…§å“ˆå¸Œè¡¨çš„ç†è®ºçŸ¥è¯†ï¼Œæ­¤æ—¶å¦‚æœç»§ç»­ä½¿å¾—å®¹å™¨ç»§ç»­ç»´æŠ¤è¿™æ ·çš„è¡¨æ ¼ä¼šå¤§å¤§é™ä½å®¹å™¨çš„æ€§èƒ½ï¼Œå¯¼è‡´ä¹‹åå…ƒç´ çš„æ’å…¥ã€æŸ¥æ‰¾å¾ˆæœ‰å¯èƒ½ä¸å¾—ä¸åœ¨é•¿åº¦å¤§äº1çš„é“¾è¡¨ä¸Šè¿›è¡Œã€‚å› æ­¤æˆ‘ä»¬å¿…é¡»æœ‰ä¸€ç§æ“ä½œä½¿å¾—æ’å…¥çš„å…ƒç´ åˆ°è¾¾æŸä¸€ä¸ªé˜ˆå€¼ï¼ˆSGI STLä¸­è®¾å®šçš„é˜ˆå€¼å°±æ˜¯bucket vectoræœ¬èº«çš„å¤§å°ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—è´Ÿè½½å› å­æ€»æ˜¯å°äº1ï¼‰ä¹‹åé‡æ–°æ‰©å¤§åˆ†é…æ–°çš„bucket vectorï¼Œå¹¶å°†åŸæ¥è¡¨æ ¼ä¸­ç»´æŠ¤çš„å„ä¸ªæ¡¶åŠå…¶æ¡¶èŠ‚ç‚¹é‡æ–°åŠ å…¥åˆ°å…¶ä¸­ã€‚è¿™ä¾¿æ˜¯SGI STL hashtableæ“ä½œ`resize()`çš„ç”±æ¥ã€‚

`resize()`æˆå‘˜å‡½æ•°åœ¨æ‰§è¡Œä¹‹åˆä¼šæ¯”è¾ƒå½“å‰hashtableä¸­çš„bucket vectorå¤§å°å’ŒæŒ‡å®šæœŸæœ›çš„å¤§å°ï¼Œåªæœ‰åœ¨æœŸæœ›å¤§å°å¤§äºåŸæ¡¶æ•°é‡çš„æƒ…å†µä¸‹æ‰ä¼šæ‰©å»ºbucket vectorã€‚è‹¥ç¡®å®éœ€è¦ï¼Œåˆ™æœ€å¼€å§‹ä¼šå…ˆåˆ›å»ºä¸€ä¸ªç¬¦åˆé¢„æœŸè´¨æ•°å¤§å°çš„ä¸´æ—¶bucket vectorï¼Œç„¶åæŒ¨ä¸ªä»åŸå…ˆçš„bucket vectorä¸­å°†æ¡¶èŠ‚ç‚¹è¿ç§»åˆ°ä¸´æ—¶bucekt vectoræ–°æ¡¶ä¹‹ä¸­ï¼ˆæ³¨æ„ï¼šæ¯ä¸€ä¸ªæ¡¶èŠ‚ç‚¹çš„å“ˆå¸Œå€¼éƒ½å¾—é‡æ–°è®¡ç®—ï¼Œä»¥ç¡®å®šå®ƒåœ¨bucket vectorä¸­çš„æ–°ä½ç½®ï¼‰ã€‚æœ€åäº¤æ¢ä¸´æ—¶bucket vectorå’ŒåŸæ¥çš„bucket vectorã€‚

```c++
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::resize(size_type __num_elements_hint)
{
  const size_type __old_n = _M_buckets.size();
  if (__num_elements_hint > __old_n) {
    const size_type __n = _M_next_size(__num_elements_hint);
    if (__n > __old_n) {
      vector<_Node*, _All> __tmp(__n, (_Node*)(0),
                                 _M_buckets.get_allocator());
      __STL_TRY {
        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {
          _Node* __first = _M_buckets[__bucket];
          while (__first) {
            //å°†æ—§å“ˆå¸Œè¡¨æ¡¶ä¸­çš„æ¡¶èŠ‚ç‚¹è¿ç§»åˆ°æ–°å“ˆå¸Œè¡¨æ¡¶ä¸­
            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);
            _M_buckets[__bucket] = __first->_M_next;
            __first->_M_next = __tmp[__new_bucket];
            __tmp[__new_bucket] = __first;
            __first = _M_buckets[__bucket];          
          }
        }
        //äº¤æ¢ä¸´æ—¶ä¸åŸå…ˆçš„bucket vector
        _M_buckets.swap(__tmp);
      }
#         ifdef __STL_USE_EXCEPTIONS
      catch(...) {
        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {
          while (__tmp[__bucket]) {
            _Node* __next = __tmp[__bucket]->_M_next;
            _M_delete_node(__tmp[__bucket]);
            __tmp[__bucket] = __next;
          }
        }
        throw;
      }
#         endif /* __STL_USE_EXCEPTIONS */
    }
  }
}
```



##### 5.5.4.1 ç‹¬ä¸€æ’å…¥æ“ä½œ

æ—¢ç„¶å·²ç»äº†è§£äº†hashtableä¸­çš„æ‰©å»ºé‡æ•´æ“ä½œ`resize()`ï¼Œé‚£ä¹ˆä¸‹é¢çš„ç‹¬ä¸€æ’å…¥æ“ä½œå’Œå¯é‡å¤æ’å…¥æ“ä½œå°±å¹¶æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå®ƒä»¬çš„ä¸åŒå°±åœ¨äºå½“å·²ç»æœ‰ç›¸åŒé”®å€¼keyçš„å…ƒç´ å­˜åœ¨äºå¯¹åº”æ¡¶é“¾è¡¨ä¸­æ—¶çš„å¤„ç†ã€‚å‰è€…åªæœ‰åœ¨éå†å®Œæ•´ä¸ªæ¡¶ä¸­é“¾è¡¨åå‘ç°æ²¡æœ‰é‡å¤é”®å€¼å…ƒç´ çš„æƒ…å†µä¸‹æ’å…¥æ–°çš„æ¡¶èŠ‚ç‚¹ï¼Œè€Œåè€…è‹¥æ˜¯å‘ç°åˆ™ä¼šåœ¨ç›¸åŒé”®å€¼èŠ‚ç‚¹çš„å‰é¢æ’å…¥æ–°çš„é‡å¤é”®å€¼æ–°èŠ‚ç‚¹ã€‚

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
public:
  /* ... */
  pair<iterator, bool> insert_unique(const value_type& __obj)
  {
    resize(_M_num_elements + 1);
    return insert_unique_noresize(__obj);
  }
  /* ... */
};

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> 
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::insert_unique_noresize(const value_type& __obj)
{
  const size_type __n = _M_bkt_num(__obj);
  _Node* __first = _M_buckets[__n];

  // å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»åœ¨æ¡¶ä¸­ï¼Œè‹¥å·²å­˜åœ¨åˆ™è¿”å›false
  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) 
    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
      return pair<iterator, bool>(iterator(__cur, this), false);

  //è‹¥ä¸å­˜åœ¨æ¡¶ä¸­ï¼Œåˆ™æ’å…¥å¹¶è¿”å›true
  _Node* __tmp = _M_new_node(__obj);
  __tmp->_M_next = __first;
  _M_buckets[__n] = __tmp;
  ++_M_num_elements;
  return pair<iterator, bool>(iterator(__tmp, this), true);
}
```



##### 5.5.4.2 å¯é‡å¤æ’å…¥æ“ä½œ

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
public:
  /* ... */
  iterator insert_equal(const value_type& __obj)
  {
    resize(_M_num_elements + 1);
    return insert_equal_noresize(__obj);
  }
  /* ... */
};

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator 
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::insert_equal_noresize(const value_type& __obj)
{
  const size_type __n = _M_bkt_num(__obj);
  _Node* __first = _M_buckets[__n];

  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) 
    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {
      //è‹¥å…ƒç´ ä¹‹å‰å°±å­˜åœ¨ï¼Œåˆ™åœ¨å…¶åæ’å…¥
      _Node* __tmp = _M_new_node(__obj);
      __tmp->_M_next = __cur->_M_next;
      __cur->_M_next = __tmp;
      ++_M_num_elements;
      return iterator(__tmp, this);
    }

  //å¦åˆ™åœ¨æ¡¶çš„å‰å¤´æ’å…¥
  _Node* __tmp = _M_new_node(__obj);
  __tmp->_M_next = __first;
  _M_buckets[__n] = __tmp;
  ++_M_num_elements;
  return iterator(__tmp, this);
}
```



#### 5.5.5 hashtableå…¶ä»–æ“ä½œ

##### 5.5.5.1 å…ƒç´ åˆ é™¤æ“ä½œ

hashtableçš„å…ƒç´ åˆ é™¤æ“ä½œæ¯”è¾ƒç®€å•ï¼Œä¸è¿‡å¯¹äº`erase()`çš„å®ç°è¿˜æ˜¯æœ‰ç‚¹æ–°é²œæ„Ÿçš„ï¼Œå®ƒç«Ÿç„¶æ˜¯å…ˆå¤„ç†ç¬¬ä¸€ä¸ªå…ƒç´ åé¢çš„èŠ‚ç‚¹ï¼Œç„¶åå†å¤„ç†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·å¤„ç†åƒ1-1-2-4-5-6çš„é“¾è¡¨å°±ä¸éœ€è¦åœ¨æœ€å‰é¢æ–½ä»¥whileåˆ é™¤é¦–ç»“ç‚¹å³æ˜¯åˆ é™¤å…ƒç´ çš„æƒ…å†µäº†ğŸ˜‹ã€‚

```c++
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()
{
  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {
    _Node* __cur = _M_buckets[__i];
    while (__cur != 0) {
      _Node* __next = __cur->_M_next;
      _M_delete_node(__cur);
      __cur = __next;
    }
    _M_buckets[__i] = 0;
  }
  _M_num_elements = 0;
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type 
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)
{
  const size_type __n = _M_bkt_num_key(__key);
  _Node* __first = _M_buckets[__n];
  size_type __erased = 0;

  if (__first) {
    _Node* __cur = __first;
    _Node* __next = __cur->_M_next;
    // å°½å¯èƒ½å…ˆåˆ é™¤æ¡¶é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªèŠ‚ç‚¹åçš„èŠ‚ç‚¹
    while (__next) {
      if (_M_equals(_M_get_key(__next->_M_val), __key)) {
        __cur->_M_next = __next->_M_next;
        _M_delete_node(__next);
        __next = __cur->_M_next;
        ++__erased;
        --_M_num_elements;
      }
      else {
        __cur = __next;
        __next = __cur->_M_next;
      }
    }
    // ç›´åˆ°whileè·³å‡ºåï¼Œæ‰åˆ¤æ–­è¦ä¸è¦åˆ é™¤ç¬¬ä¸€ä¸ªæ¡¶èŠ‚ç‚¹
    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
      _M_buckets[__n] = __first->_M_next;
      _M_delete_node(__first);
      ++__erased;
      --_M_num_elements;
    }
  }
  return __erased;
}
```



##### 5.5.5.2 æŸ¥æ‰¾æ“ä½œ

```c++
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
public:
  /* ... */
  iterator find(const key_type& __key) 
  {
    size_type __n = _M_bkt_num_key(__key);
    _Node* __first;
    for ( __first = _M_buckets[__n];
          __first && !_M_equals(_M_get_key(__first->_M_val), __key);
          __first = __first->_M_next)
      {}
    return iterator(__first, this);
  } 
  /* ... */
};
```



### 5.6 hashtableè¡ç”Ÿçš„æ— åºå…³è”å®¹å™¨

åœ¨SGI STLä¸­ç”±äºhashtableè¡ç”Ÿå‡ºæ¥çš„æ— åºå…³è”å®¹å™¨åœ¨é‚£ä¸ªå¹´ä»£è¿˜æœªåŠ å…¥åˆ°C++çš„æ ‡å‡†ä¸­ï¼Œå®ƒä»¬å¹¶æ²¡æœ‰è§„èŒƒã€å®Œæ•´çš„hashä»¿å‡½æ•°ã€åˆ¤ç­‰equalKeyä»¿å‡½æ•°å¯ä»¥ä¾›ä½¿ç”¨ï¼Œå› æ­¤ç”¨æˆ·å¿…é¡»ä¸ºè¿™äº›å®¹å™¨æä¾›é’ˆå¯¹å¥keyçš„ç‰¹ä¾‹åŒ–hashä»¿å‡½æ•°å’Œåˆ¤æ–­equalKeyä»¿å‡½æ•°ã€‚å½“ç„¶åœ¨å½“å‰æ—¶ä»£ä¸‹ï¼Œæ— åºå…³è”å®¹å™¨unordered_mapã€unordered_setã€unordered_multimapã€unordered_mutlisetå¹¶æ²¡æœ‰è¿™ç§æ‹…å¿§ã€‚

ç”±äºä¸‹é¢çš„æ— åºå…³è”å®¹å™¨åŸºæœ¬ä¸Šéƒ½æ˜¯hashtableè¿™ä¸€å®¹å™¨çš„ç®€å•å°è£…ï¼Œå¹¶æ²¡æœ‰å¤ªå¤šçš„å­¦ä¹ ä»·å€¼ï¼Œå› æ­¤ä»…ç®€å•çš„åˆ—å‡ºå…³é”®çš„ä»£ç éƒ¨åˆ†ã€‚

#### 5.6.1 hash_set

```c++
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
class hash_set
{
  /* ... */
private:
  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, 
                    _EqualKey, _Alloc> _Ht;
  _Ht _M_ht;
  /* ... */
};
```



#### 5.6.2 hash_map

```c++
template <class _Key, class _Tp, class _HashFcn, class _EqualKey,
          class _Alloc>
class hash_map
{
  /* ... */
private:
  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,
                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;
  _Ht _M_ht;

  /* ... */
  _Tp& operator[](const key_type& __key) {
    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;
  }
  /* ... */
};
```



#### 5.6.3 hash_multiset

```c++
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
class hash_multiset
{
  /* ... */
private:
  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, 
                    _EqualKey, _Alloc> _Ht;
  _Ht _M_ht;
  /* ... */
};
```



#### 5.6.4 hash_multimap

```c++
template <class _Key, class _Tp, class _HashFcn, class _EqualKey, 
          class _Alloc>
class hash_multimap
{
  /* ... */
private:
  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,
                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> 
          _Ht;
  _Ht _M_ht;
  /* ... */
};
```



